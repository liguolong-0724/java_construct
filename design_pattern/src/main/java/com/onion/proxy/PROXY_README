##静态代理：
缺点：
一个代理类只能对一个业务接口的实现类进行包装，如果有多个业务接口的话就要定义很多实现类和代理类才行。
而且，如果代理类对业务方法的预处理、调用后操作都是一样的（比如：调用前输出提示、调用后自动关闭连接），则多个代理类就会有很多重复代码。


##动态代理：
####JDK动态代理：实现InvocationHandler接口
* JDK动态代理所用到的代理类在程序调用到代理类对象时才由JVM真正创建，JVM根据传进来的业务实现类对象以及方法名 ，
动态地创建了一个代理类的class文件并被字节码引擎执行，然后通过该代理类对象进行方法调用。
* 被代理类一定要实现接口。

####CGLIB(Code Generator Library)动态代理：实现MethodInterceptor接口
* cglib是针对类来实现代理的，原理是对指定的业务类生成一个子类，并覆盖其中业务方法实现代理。
* 因为采用的是继承，所以不能对final修饰的类进行代理。

####JDK与CGLIB性能比较
* CGLib所创建的动态代理对象在实际运行时候的性能要比JDK动态代理高不少，有研究表明，大概要高10倍；
* 但是CGLib在创建对象的时候所花费的时间却比JDK动态代理要多很多，有研究表明，大概有8倍的差距(jdk1.8之后性能差别不大)；
* 因此，对于singleton的代理对象或者具有实例池的代理，因为无需频繁的创建代理对象，所以比较适合采用CGLib动态代理，反之，则比较适用JDK动态代理。